// Generated from /home/valavanca/Documents/hal/jastadd-exercise/jastadd_task/build/tmp/preprocessParser/ExpressionParser.all
package de.tudresden.inf.st.most.jastadd.parser;
 import de.tudresden.inf.st.most.jastadd.ast.*; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ExpressionParser.beaver".
 */
public class ExpressionParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MINUS = 1;
		static public final short NUMBER = 2;
		static public final short IDENTIFIER = 3;
		static public final short LP = 4;
		static public final short RP = 5;
		static public final short PLUS = 6;
		static public final short MULT = 7;
		static public final short DIV = 8;
		static public final short NEWLINE = 9;
		static public final short EQUALS = 10;

		static public final String[] NAMES = {
			"EOF",
			"MINUS",
			"NUMBER",
			"IDENTIFIER",
			"LP",
			"RP",
			"PLUS",
			"MULT",
			"DIV",
			"NEWLINE",
			"EQUALS"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oLaZjFmq0GXCS99ZYs4nB2quGW10q28HgWegIWe82EWeA2WeA2XfRVZ4ESy5fcpsVhOWG" +
		"I7dsQsStQETyPm9DCP88P#2AQZ5wfLBxGC4arb242hAAfoIYL56le8z9aD9Onvj71WYQZJ3" +
		"Bqi8HbJKOZ6M4T2JOqcIf4Z1NCeeO1wl9IrFAHozGj$hvOfZcqqIshNrpUhTwiFdC1y3WJq" +
		"NrED$WqxUWLJdL2D5cx7OzhhCxubKvUkvs0TmLbHvzHvsxh2dITHVtJYpHzttyTs7msBuTJ" +
		"elKPqRS$9nVaaboHJZw6QnAGBad83TaYs#IMx99zSaVso97PEV1KWMDoGEx98NaWZ$R$JzJ" +
		"vZMNgjbUp7ZYzNf5jdJYvx#GTT#ulx9NlTelx4jDZUiHJYSnP#1Nqd3r3#nijNPWV");

	public ExpressionParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new Root(new List<Def>(), exp);
			}
			case 1: // goal = def_list.def_list exp.exp
			{
					final Symbol _symbol_def_list = _symbols[offset + 1];
					final List def_list = (List) _symbol_def_list.value;
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new Root(def_list, exp);
			}
			case 2: // def_list = def.def
			{
					final Symbol _symbol_def = _symbols[offset + 1];
					final Def def = (Def) _symbol_def.value;
					 return new List().add(def);
			}
			case 3: // def_list = def_list.def_list def.def
			{
					final Symbol _symbol_def_list = _symbols[offset + 1];
					final List def_list = (List) _symbol_def_list.value;
					final Symbol _symbol_def = _symbols[offset + 2];
					final Def def = (Def) _symbol_def.value;
					 return def_list.add(def);
			}
			case 4: // def = IDENTIFIER.IDENTIFIER EQUALS.EQUALS MINUS.MINUS NUMBER.NUMBER NEWLINE.NEWLINE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol MINUS = _symbols[offset + 3];
					final Symbol NUMBER = _symbols[offset + 4];
					final Symbol NEWLINE = _symbols[offset + 5];
					 return new Def((String)IDENTIFIER.value, -Float.parseFloat((String)NUMBER.value));
			}
			case 5: // def = IDENTIFIER.IDENTIFIER EQUALS.EQUALS NUMBER.NUMBER NEWLINE.NEWLINE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol NUMBER = _symbols[offset + 3];
					final Symbol NEWLINE = _symbols[offset + 4];
					 return new Def((String)IDENTIFIER.value, Float.parseFloat((String)NUMBER.value));
			}
			case 6: // exp = LP.LP exp.a PLUS.PLUS exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol PLUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new AddExp(a, b);
			}
			case 7: // exp = LP.LP exp.a MULT.MULT exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol MULT = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new MulExp(a, b);
			}
			case 8: // exp = LP.LP exp.a DIV.DIV exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol DIV = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new DivExp(a, b);
			}
			case 9: // exp = LP.LP exp.a MINUS.MINUS exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol MINUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new MinusExp(a, b);
			}
			case 10: // exp = MINUS.MINUS exp.a
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					 return new UnaryMinusExp(a);
			}
			case 11: // exp = NUMBER.NUMBER
			{
					final Symbol NUMBER = _symbols[offset + 1];
					 return new de.tudresden.inf.st.most.jastadd.ast.Number(Float.parseFloat((String)NUMBER.value));
			}
			case 12: // exp = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new Var((String)IDENTIFIER.value);
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
